import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import tasktracker.tasks.Epic;
import tasktracker.managers.HistoryManager;
import tasktracker.managers.InMemoryHistoryManager;
import tasktracker.managers.InMemoryTaskManager;
import tasktracker.managers.Managers;
import tasktracker.tasks.Subtask;
import tasktracker.tasks.Task;
import tasktracker.managers.TaskManager;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class TaskTrackerTest {

    TaskManager taskManager;

    @BeforeEach
    void createManager() {
        taskManager = Managers.getDefault();
    }

    @Test
    void shouldCorrectCreateNewTask() {
        Task task = new Task("Test", "Test description", Task.Status.NEW, 10);
        taskManager.createNewTask(task);
        final int taskId = InMemoryTaskManager.getTaskID();

        final Task savedTask = taskManager.getTaskWithID(taskId - 1);

        assertNotNull(savedTask, "Задача не найдена.");
        assertEquals(task, savedTask, "Задачи не совпадают.");

        final List<Task> tasks = taskManager.getTaskList();

        assertNotNull(tasks, "Задачи не возвращаются.");
        assertEquals(1, tasks.size(), "Неверное количество задач.");
        assertEquals(task, tasks.get(0), "Задачи не совпадают.");
    }

    @Test
    void shouldCheckEqualityOfTaskObjectsWithCommonID() {
        Task task1 = new Task("Test task1", "Test description", Task.Status.NEW, 42);
        Task task2 = new Task("Test task2", "Test description", Task.Status.DONE, 42);


        assertEquals(task1, task2, "Задачи с одинаковым id должны быть равны");
        assertTrue(task1.equals(task2), "equals должен вернуть true для одинаковых id");
        assertEquals(task1.hashCode(), task2.hashCode(), "hashCode должен совпадать");


    }

    @Test
    void shouldCheckEqualityOfTaskExtendedObjects() {
        Subtask subtask1 = new Subtask("Test subtask1", "test desc",
                Task.Status.DONE, 14);
        Subtask subtask2 = new Subtask("Test subtask2", "test desc",
                Task.Status.NEW, 14);

        assertEquals(subtask1, subtask2, "подзадачи должны относиться к одному epic");

        Epic epic1 = new Epic("Test epic1", "test desc",
                10);
        Epic epic2 = new Epic("Test epic2", "test desc",
                10);

        assertEquals(epic1, epic2, "эпики с одинаковым ID должны совпадать");

    }

    @Test
    void shouldRejectEpicAsItsOwnSubtask() {

        Epic epic = new Epic("Test epic", "test desc",
                7);
        taskManager.createNewEpic(epic);

        int epicId = epic.getTaskId();

        Subtask bad = new Subtask("bad", "desc", Task.Status.NEW,
                epicId);
        bad.setTaskId(epicId);

        assertThrows(IllegalArgumentException.class,
                () -> taskManager.createNewSubtask(bad));

    }

    @Test
    void shouldRejectSubtaskBeingItsOwnEpic() {
        Epic epic = new Epic("Epic", "desc", 0);
        taskManager.createNewEpic(epic);

        int epicId = epic.getTaskId();

        Subtask bad = new Subtask("bad", "desc", Task.Status.NEW,
                epicId);
        bad.setTaskId(epicId);

        assertThrows(IllegalArgumentException.class,
                () -> taskManager.createNewSubtask(bad),
                "Подзадача не может ссылаться на саму себя как на эпик");

    }

    @Test
    void shouldReturnCreatedTaskManagerObject() {
        TaskManager manager = Managers.getDefault();
        assertNotNull(manager, "экземпляр менеджера должен быть проинициализирован");
    }

    @Test
    void shouldCheckCorrectAddingTasksForInMemoryTaskManagerAndItsSearch() {


        // 1) Эпик
        Epic epic = new Epic("epic", "testEpic", 0);
        taskManager.createNewEpic(epic);
        int epicId = taskManager.getEpictaskWithID(1).getTaskId();

        // 2) Обычная задача
        Task task = new Task("task", "testTask", Task.Status.IN_PROGRESS, 2);
        taskManager.createNewTask(task);
        int taskId = task.getTaskId();

        // 3) Подзадача
        Subtask subtask = new Subtask("subtask", "testSubtask", Task.Status.DONE, epicId);
        taskManager.createNewSubtask(subtask);
        int subtaskId = subtask.getTaskId();

        // 4) проверки наличия
        assertFalse(taskManager.getTaskList().isEmpty());
        assertFalse(taskManager.getEpicList().isEmpty());
        assertFalse(taskManager.getSubtaskList().isEmpty());

        // 5) проверки поиска по id
        Task savedTask = taskManager.getTaskWithID(2);
        assertNotNull(savedTask);

        assertEquals("task", savedTask.getTaskName());
        assertEquals("testTask", savedTask.getTaskDescription());
        assertEquals(Task.Status.IN_PROGRESS, savedTask.getStatus());
        assertEquals(taskId,savedTask.getTaskId());



    }

    @Test
    void tasksWithDefaultIdMustNotConflictWithAutoGeneratedID() {

        // первая задача, id назначит менеджер
        Task task1 = new Task("task1", "desc1", Task.Status.NEW);
        taskManager.createNewTask(task1);
        int id1 = task1.getTaskId();

        // вторая задача, предварительно назначаем ей конфликтный ID
        Task task2 = new Task("task2", "desc2", Task.Status.DONE);
        task2.setTaskId(id1);

        // менеджер должен назначить задаче свой ID (перезаписать)
        taskManager.createNewTask(task2);
        int id2 = task2.getTaskId();

        // проверяем
        assertNotEquals(id1, id2, "менеджер должен выдать новый id и не допустить конфликта");
        assertEquals(task1, taskManager.getTaskWithID(id1),
                "первая задача должна остаться доступной по своему id");
        assertEquals(task2, taskManager.getTaskWithID(id2),
                "вторая задача должна быть доступна по новому (сгенерированному) id");

        assertEquals(2, taskManager.getTaskList().size(), "обе задачи должны храниться в менеджере");

    }

    @Test
    void shouldCheckThatTaskNotChangedWhenSheAddedInManager() {
        Task task = new Task("task", "desc", Task.Status.DONE);

        taskManager.createNewTask(task);
        Task taskInManager = taskManager.getTaskWithID(task.getTaskId());

        assertEquals(task.getTaskName(), taskInManager.getTaskName(),
                "менеджер неверно добавил задачу (несовпадение имён)");
        assertEquals(task.getTaskDescription(), taskInManager.getTaskDescription(),
                "менеджер неверно добавил задачу (различные описания)");
        assertEquals(task.getStatus(), taskInManager.getStatus(),
                "менеджер неверно добавил задачу (отличные друг от друга статусы)");
        assertEquals(task, taskInManager, "несовпадение по идентификатору (taskID)");

    }

    @Test
    void shouldStoreLastReleaseOfTaskInHistory() {
        HistoryManager historyManager = new InMemoryHistoryManager();
        Task originalTask = new Task("Task1", "desc", Task.Status.NEW);
        // добавляем в историю копию задачи
        Task originalTaskCopy = new Task("Task1", "desc", Task.Status.NEW);
        historyManager.add(originalTaskCopy);


        // меняем исходный объект
        originalTask.setStatus(Task.Status.IN_PROGRESS);

        // получаем задачу из истории
        List<Task> taskList = historyManager.getHistory();
        Task taskFromHistory = taskList.get(0);


        // проверяем, что в истории осталась старая версия
        assertEquals(Task.Status.NEW, taskFromHistory.getStatus(), "статус в истории должен остаться прежним");


    }


}